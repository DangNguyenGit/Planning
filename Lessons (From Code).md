### What We Learned from the Coding (From Test/Base Code)

***Adding Images to Game (Code):***
We have first received this code with the help of Ms.Luce but unfortunately could not tune the coding to be suitable for our game.
The code ended up covering up the entire screen with an image, thus making it almost impossible for the player to play the game (due
to the lack of vision of the actual bricks and paddle). From the coding, we have learned how to include an image into the game by turning
the image into an object (JLabel) and inserting it into the game by attaching it into a JFrame. The image can be adjusted by changing the
dimensions of the JFrame and can be visible by using a simple setVisible method. The JFrame.EXIT_ON_CLOSE (with the default close operation code at the top)
also exits the application when the player wants to exit the game as well (unlike the other default close operations availible). 

***Adding Audio to the Game (Soundeffect to be more specific):***
We have figured out how to implement this piece of coding by watching around two videos (in which one was significantly more useful than the other).
The first small detail that we learned while watching the video and using the code is the usage of "Exception ex" instead of the standard "Exception e". 
This small change actually allows us to use the "ex.printStackTrace();" which prints out the actual entire error message. This makes debugging the code
much easier. The first piece of this code is creating a file object (shown in the code). The "musicLocation" is the string that we pass through the playMusic
method in the main class. (import java.io.File is also needed but was not included in the base code) We then create a small if statement, shown in the code, to check whether the file (music audio) actually exists within the game files (also needs two other imports which are AudioInputStream and AudioSystem classes). Now that we have figured out (or in better terms, the code has figured out) that the file actually exists, we create another small line of code that takes the audio file and inputs it into the game/project. This code is found in the "if musicPath exists" section. When then use the Clip class (also imported) and clip object to actually obtain the Audio stream from the audioInput object (in
the base code). Then we write a line of code to actually open the audio clip (Clip.open(audioInput);). After this is done we go to our main class and make/type a line of code to reference our previous class (which also includes our method to play the music) by creating an instance (ie. musicPath musicObject = new musicStuff();). Then after that we write "String filepath = "audio.wav" to actually use the audio file we want to play (this step is before the instance part, and the audio.wav is a placeholder for the audio clip). Then we create a line of code which play the file we want with the usage of the method we created in the previous class (ie. musicObject.playMusic(filepath);) In the original code the person used an X-Button or escape panel as an interruptor but we altered that to suit our game. 

Generally Speaking: We learned how to include soundeffects into our game with several different techniques such as creating instances, importing classes, referencing and more. 

***Coding the Paddle Movements (and Player Keystrokes) of the In-Game Player Paddle:***
We have figured out how to create and encode the paddle movements of our game by using a Youtube tutorial online (link 1 of the General.md file). The first thing we did with the base code is we created a class specifically for the key movements (as shown in the code) called keyPressed. Within this class we have the coding to actually spawn the game and start the game (basically meaning the moment the player clicks the SPACE key the player starts playing). The condition in the first if statement essentially says "when the player clicks the spacebar on their keyboard...move to next statement". The next if statement basically states that when the game is in play (!play) the game will begin (begin the actual gameplay as the assets of the game are currently frozen in place shown in the code). The general idea of the two other if statements outside of the keyPressed class is that when the player clicks either the right or left key, the player will then move towards either direction of the screen (ie. Player presses right key, paddle moves right). The start of the if statements simply have the condition of "if the player touches right/left key...do this..." which is as expected. The first condtion of the two if statements (the if statements contained within the other if statements) esscentially are restraints for the paddle to make sure that it doesn't move infinitely right or infinitely left (meaning that the paddle will move outside of the screen). The condition simply states "if the paddle is past position x, paddle will be in position x". This means that the paddle will not pass that specific postion (in this case position x). The else statements simply state that the paddle will move towards the right or left if the previous if statement condition is not met. The speed of the paddle (and the general movement) is made in two different methods (moveLeft, moveRight) which is simply shows the intervals at which the paddle moves from either direction (ie. paddlePosX += 20). 

***Coding the Ball Movement:***
When coding the ball movement of the game, we realised that the ball movement code is essentially the same as the paddle movement but even simpler. This is due to the fact that within the code, we do not need to consider the player keystrokes. The first two lines of the code essentially just outlines the intrevals of which the ball is moving by (BallPosY is moving up by the intreval of BallDirY). The if statements essentially say that the ball moves in the opposite direction once it reaches the listed X and Y coordinates. This is to ensure the fact that the ball will not move infinitely in either direction of the screen (meaning the ball will move off the screen and never return to the paddle or hit the bricks). 

***Ball Collision with Objects:***
The general idea of the code is that when the ball intersects or touches the location (length and width) of the brick, the ball will move towards the opposite direction. The conditional statements and if statements essentially detail the how the ball needs to touch brick in the listed values to move the opposite direction in the x-axis, and if it doesn't meet these conditions, it moves in the opposite direction in the y-axis. The "sound2" line of code essentially plays a sound effect when the ball hits the brick. The "totalbricks--" means that when the ball hits the brick, the brick is removed from the total bricks in the game. The "mapAccess.setBrickValue" is essentially to set the values of the brick according to the Brick Map Class (in which is accessed through mapAccess) so that the X-Y values (as in the Length and Width) of the brick can be set.

NOTE: The code listed in the base code file in the repository is the code for the ball's collision with the bricks in the game. We did not include the paddle collision code due to the fact that the code is essentially the exact same with minor differences. (Differences being that the paddle doesn't vanish when the ball hits it.)

***Coding the Random In-Game Challenges***
While trying to code the in-game challenges we ran into a few issues. We first try to directly inmplement the in-game changes with if statements but the issue was that the speed of the ball would stay the same althroughout the entire gameplay. Meaning that the ball would not return to its original speed. It would also stay in that singular changed speed throughout the whole game, meaning that it won't change multiple times during the game. To remove this issue we created a switch/case statement/loop. The first and most important line of the code we created was the "chooseChallenge = r.nextInt();" line. This line is important as it determines which power-up and challenge is chosen. The value chooseChallenge is used to choose the value of the switch/case statements, and the chooseChallenge values are determined by the Random Number method. The random number method is imported through java.util.Random. The usage of the method is basically to make the challenges completely random within the gameplay by choosing random integers in which trigger certain situations if the values of the integers match the cases. The switch/case statements in a general sense simply define what sort of changes will happen to the game if this case condition is met (meaning that the chooseChallenge integer value is the same as the case number). 


